<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>FrontEnd on 펭귄의 외부 저장소</title><link>https://blog.seungyeop-lee.com/categories/frontend/</link><description>Recent content in FrontEnd on 펭귄의 외부 저장소</description><generator>Hugo -- gohugo.io</generator><language>ko-KR</language><lastBuildDate>Wed, 23 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.seungyeop-lee.com/categories/frontend/index.xml" rel="self" type="application/rss+xml"/><item><title>React Standard Architecture</title><link>https://blog.seungyeop-lee.com/post/react-standard-architecture/</link><pubDate>Wed, 23 Nov 2022 00:00:00 +0000</pubDate><guid>https://blog.seungyeop-lee.com/post/react-standard-architecture/</guid><description>&lt;img src="https://blog.seungyeop-lee.com/post/react-standard-architecture/cover.png" alt="Featured image of post React Standard Architecture" />&lt;p>Next.js에서 사용 가능한 React 표준(범용) 아키텍처를 고민 할 일이 생겨서 여기에 그 과정을 정리한다.&lt;/p>
&lt;p>아키텍처는 아직 완성되지 않았다고 생각하며, 개선점이 나올 때마다 이 글에 업데이트 할 예정이다.&lt;/p>
&lt;p>(&lt;strong>이 글을 참고하여 저작물을 생산하시는 경우, 출처를 남겨주시길 부탁드리겠습니다.&lt;/strong>)&lt;/p>
&lt;h2 id="기본-설계-방향">기본 설계 방향&lt;/h2>
&lt;ul>
&lt;li>각 요소의 역할이 뚜렷하고 중복되지 않도록한다.&lt;/li>
&lt;li>의존관계가 순환하지 않도록한다.&lt;/li>
&lt;/ul>
&lt;h2 id="version1">version1&lt;/h2>
&lt;p>&lt;a class="link" href="https://medium.com/@yujso66/%EB%B2%88%EC%97%AD-%EC%9C%84%EC%A0%AF-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-b3e95b261c18" title="[번역] 위젯 주도 개발"
target="_blank" rel="noopener"
>위젯 주도 개발&lt;/a>이라는 글에서 힌트를 얻어 기본적인 역할 별로 요소를 나누고 서로의 의존관계를 설정하였다.&lt;/p>
&lt;p>&lt;img src="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version1.png"
width="1422"
height="602"
srcset="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version1_hub9e6408302b398891b5046358d5509c6_50535_480x0_resize_box_3.png 480w, https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version1_hub9e6408302b398891b5046358d5509c6_50535_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="version1"
class="gallery-image"
data-flex-grow="236"
data-flex-basis="566px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>pages&lt;/strong>: routing에 대한 책임을 갖는다. nextjs의 특성상 pages폴더의 구조가 routing rule이므로 단순히 해당 page에 해당하는 widget을 호출하는 역할 만 수행한다.&lt;/li>
&lt;li>&lt;strong>widgets&lt;/strong>: 특정 페이지에서 사용되는 complex component를 조합하는 책임을 갖는다. query를 사용해 페이지 내 공통 데이터 관리 및 complex component 사이의 연결 책임도 수행한다.&lt;/li>
&lt;li>&lt;strong>components&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>complex&lt;/strong>: base component를 조합하고, 연결하는 책임을 갖는다. query를 사용해 기능 내 데이터 관리를 수행한다.&lt;/li>
&lt;li>&lt;strong>base&lt;/strong>: 화면에 보여지는 markup &amp;amp; css를 담당한다. view에 대한 책임을 갖는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>queries&lt;/strong>: 데이터 상태를 관리한다. 주로 API 서버와 통신하는 역할을 한다.&lt;/li>
&lt;/ul>
&lt;h2 id="version2">version2&lt;/h2>
&lt;p>&lt;a class="link" href="#version1" >version1&lt;/a>의 구조를 바탕으로 각 역할에 대해 좀 더 드릴 다운하였다.&lt;/p>
&lt;p>&lt;img src="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version2.png"
width="2282"
height="1440"
srcset="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version2_hu283887e9c5f03a10c66a37e72765c820_190333_480x0_resize_box_3.png 480w, https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version2_hu283887e9c5f03a10c66a37e72765c820_190333_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="version2"
class="gallery-image"
data-flex-grow="158"
data-flex-basis="380px"
>&lt;/p>
&lt;ul>
&lt;li>이하를 제외하고는 &lt;a class="link" href="#version1" >version1&lt;/a>과 상동&lt;/li>
&lt;li>&lt;strong>widgets&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>widget&lt;/strong>: 특정 페이지의 layout 및 complext component를 조합한다.&lt;/li>
&lt;li>&lt;strong>hook&lt;/strong>: 영속화 데이터 로직을 책임진다. query를 이용해 데이터를 다룬다.&lt;/li>
&lt;li>&lt;strong>css&lt;/strong>: layout에 필요한 스타일을 정의한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>components&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>complex&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>component&lt;/strong>: base component를 조합하고, 배치한다.&lt;/li>
&lt;li>&lt;strong>hook&lt;/strong>: UI 로직을 책임진다.&lt;/li>
&lt;li>&lt;strong>store&lt;/strong>: complex component의 내부 상태를 관리한다.&lt;/li>
&lt;li>&lt;strong>css&lt;/strong>: complex component에 필요한 스타일을 정의한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>base&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>component&lt;/strong>: 더 기본적인 base component의 조합 및 markup을 담당한다.&lt;/li>
&lt;li>&lt;strong>css&lt;/strong>: base component에 필요한 스타일을 정의한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>queries&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>query&lt;/strong>: 서버에서 받은 데이터를 상태로서 관리한다.&lt;/li>
&lt;li>&lt;strong>data&lt;/strong>: 서버에서 받은 데이터이다.&lt;/li>
&lt;li>&lt;strong>util func&lt;/strong>: 서버에서 받은 데이터를 해석하여 기능을 제공해주는 함수 집합이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="version3">version3&lt;/h2>
&lt;p>&lt;a class="link" href="#version2" >version2&lt;/a>의 의존관계가 명료하지 않고, 역할이 중복된 느낌을 받아 전체적인 리팩토링이 필요하다고 판단하였다.&lt;/p>
&lt;p>widget의 모음을 나타내는 단어로서 &lt;a class="link" href="https://github.com/alan2207/bulletproof-react" title="Bulletproof React"
target="_blank" rel="noopener"
>Bulletproof React&lt;/a> 레포지토리에서 사용된 feature(기능)라는 용어를 차용하여 아키텍처를 재구성하였다.&lt;/p>
&lt;p>기능을 계층적으로 세분화하여 만드는 경우를 고려하여 프랙털 구조를 갖도록 설계하였다.&lt;/p>
&lt;p>&lt;img src="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version3.png"
width="2202"
height="1502"
srcset="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version3_hud4c65f90d2851e552a53d032a12553d3_244132_480x0_resize_box_3.png 480w, https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version3_hud4c65f90d2851e552a53d032a12553d3_244132_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="version3"
class="gallery-image"
data-flex-grow="146"
data-flex-basis="351px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>page&lt;/strong>: routing 및 static page를 생성한다. feature가 배치될 layout도 여기서 정해진다.&lt;/li>
&lt;li>&lt;strong>feature&lt;/strong>: 하나의 기능을 나타내는 단위로, page에서 호출 될 때는 Header, LNB, GNB, Footer를 제외한 main 부분(contents 부분)을 의미한다.
&lt;ul>
&lt;li>&lt;strong>entry&lt;/strong>: feature를 호출하기위한 입구에 해당하는 요소, widget을 조합하고, feature mode에 따라 widget을 변경한다.
&lt;ul>
&lt;li>&lt;strong>feature logic&lt;/strong>: feature mode관리, feature 내 공통 데이터 관리 등을 담당한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>widget&lt;/strong>: main 부분을 구성하는 소 기능을 담당한다.
&lt;ul>
&lt;li>&lt;strong>container&lt;/strong>: data logic을 만들어서 presentation에 주입하는 역할을 한다.
&lt;ul>
&lt;li>&lt;strong>data logic&lt;/strong>: 영속화 데이터 로직을 책임진다. react query를 이용하여 데이터를 다룬다.&lt;/li>
&lt;li>&lt;strong>react query&lt;/strong>: 영속화 데이터 상태 관리 라이브러리로서, API를 통해 받은 데이터를 관리한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>presentation&lt;/strong>: 여러개의 component를 조합하고, ui logic을 이용해 각 component를 연결한다.
&lt;ul>
&lt;li>&lt;strong>ui logic&lt;/strong>: ui 내부의 상태를 관리한다. zustand를 이용하여 상태를 저장, 조작한다.&lt;/li>
&lt;li>&lt;strong>zustand&lt;/strong>: 범용 상태 관리 라이브러리로서 상태와 로직을 응집성 높게 관리 할 수 있는 장점이 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>api&lt;/strong>: API호출의 역할을 갖는다.&lt;/li>
&lt;li>&lt;strong>component&lt;/strong>: 화면에 보여지는 markup &amp;amp; css를 담당한다. view에 대한 책임을 갖는다. 특정 상황에서는 스스로의 상태도 갖는다. (ex. form)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>util&lt;/strong>: 공통 유틸 함수 모음&lt;/li>
&lt;li>&lt;strong>lib&lt;/strong>: 외부 라이브러리 wrapping 함수 모음&lt;/li>
&lt;li>&lt;strong>component&lt;/strong>: 프로젝트의 공용 component&lt;/li>
&lt;li>&lt;strong>state&lt;/strong>: 프로젝트 내 공통 데이터 상태 관리&lt;/li>
&lt;/ul>
&lt;h2 id="version4">version4&lt;/h2>
&lt;p>영속화 데이터 상태 관리부분과 api 호출부분의 연관성이 높으므로 repository로 그룹화하였다.
그로인해 widget의 책임이 줄어들고, 역할이 더 명확해졌다.
또한, repository부분을 mocking하는 것으로 서버부분의 구현이 없이도 화면개발이 용이해져 유연성이 향상되었다.&lt;/p>
&lt;p>단순 API호출이 필요한 경우에는 react query를 통하지 않고, widget에서 바로 api호출이 가능하도록하였다.&lt;/p>
&lt;p>zustand를 제외 함으로서, 상태관리를 구현자의 재량에 맡기도록하였다.&lt;/p>
&lt;p>&lt;img src="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version4.png"
width="2202"
height="1622"
srcset="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version4_huf50315dfba439bdcf25d7af8964d3731_263433_480x0_resize_box_3.png 480w, https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version4_huf50315dfba439bdcf25d7af8964d3731_263433_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="version4"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="325px"
>&lt;/p>
&lt;ul>
&lt;li>이하를 제외하고는 &lt;a class="link" href="#version3" >version3&lt;/a>와 상동&lt;/li>
&lt;li>&lt;strong>feature&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>repository&lt;/strong>: widget에서 사용할 데이터에 대한 CRUD의 책임을 갖는 요소
&lt;ul>
&lt;li>&lt;strong>react query&lt;/strong>: widget에서 사용할 데이터의 상태를 관리한다.&lt;/li>
&lt;li>&lt;strong>api&lt;/strong>: react query 및 widget에서 직접 호출해서 사용할 API의 호출 역할을 갖는다.&lt;/li>
&lt;li>&lt;strong>type&lt;/strong>: 기능 내 사용 데이터 타입을 정의한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="version5">version5&lt;/h2>
&lt;p>widget의 책임이 줄어듦으로서, container와 presentation, data logic과 ui logic으로 나눈 설계가 표준 아키텍처로 사용하기에는 과해 보였다.
(&lt;a class="link" href="#version4" >version4&lt;/a>로 만든 간단한 게시판에서 컬럼 1개를 삭제하는 작업을 했을 때, 수정해야하는 부분이 너무 많다고 느껴졌다.)&lt;/p>
&lt;p>그래서 container와 presentation을 widget으로, data logic과 ui logic을 widget logic으로 통폐합하였다.&lt;/p>
&lt;p>&lt;img src="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version5.png"
width="2202"
height="1622"
srcset="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version5_hud4d4def15cc909a546a1bd6011fcc5ff_241592_480x0_resize_box_3.png 480w, https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version5_hud4d4def15cc909a546a1bd6011fcc5ff_241592_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="version5"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="325px"
>&lt;/p>
&lt;ul>
&lt;li>이하를 제외하고는 &lt;a class="link" href="#version4" >version4&lt;/a>와 상동&lt;/li>
&lt;li>&lt;strong>feature&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>widget&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>widget&lt;/strong>: main 부분을 구성하는 소 기능을 담당한다. component를 조합하고, widget logic을 이용해 각 component를 연결한다.&lt;/li>
&lt;li>&lt;strong>widget logic&lt;/strong>: 영속화 데이터 로직과 UI 로직을 담당한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="version6">version6&lt;/h2>
&lt;p>widget에서 사용하는 데이터 타입과 api를 통해 전달되는 데이터의 형태가 다른 패턴이 발생 할 수 있음을 확인하였으므로 수정작업을 진행하였다.
(ex. 1개의 widget에서 사용하는 데이터가 2개 이상의 api를 조합하여 만들 필요가 있는 경우)&lt;/p>
&lt;p>그래서 api 매핑용 데이터 타입 (api type)과 widget용 데이터 타입(type)으로 나누었다.&lt;/p>
&lt;p>&lt;img src="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version6.png"
width="2202"
height="1622"
srcset="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version6_hud4d4def15cc909a546a1bd6011fcc5ff_257979_480x0_resize_box_3.png 480w, https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version6_hud4d4def15cc909a546a1bd6011fcc5ff_257979_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="version6"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="325px"
>&lt;/p>
&lt;ul>
&lt;li>이하를 제외하고는 &lt;a class="link" href="#version5" >version5&lt;/a>와 상동&lt;/li>
&lt;li>&lt;strong>feature&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>type&lt;/strong>: widget에서 사용하는 데이터의 타입을 정의한다.&lt;/li>
&lt;li>&lt;strong>repository&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>api type&lt;/strong>: API를 통해 받은 데이터를 매핑하기 위한 타입을 정의한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="version7">version7&lt;/h2>
&lt;p>version6를 실제로 사용해 보았을 때, widget logic이 react query가 제공하는 타입에 암묵적 의존하는 것을 확인하였다.
그로 인해, 서버가 아직 준비되어 있지 않아, mock 데이터를 우선 사용하여 화면작업을 해야하는 경우,
주니어 개발자들이 많이 헤메는 현상을 확인하였다.&lt;/p>
&lt;p>이러한 어려움을 해소하고자, repository와 react query를 분리하는 수정작업을 진행하였다.&lt;/p>
&lt;p>또한 api type의 사용을 선택적으로 하도록 변경하였다.
(기본적으로 화면 전용 API를 서버에서 제공해주기로 내부 의사 결정이 일어난것에 따름)&lt;/p>
&lt;p>&lt;img src="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version7.png"
width="2142"
height="1848"
srcset="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version7_hued58e456996827b40ab15a02461d90ce_262109_480x0_resize_box_3.png 480w, https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version7_hued58e456996827b40ab15a02461d90ce_262109_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="version7"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="278px"
>&lt;/p>
&lt;ul>
&lt;li>이하를 제외하고는 &lt;a class="link" href="#version6" >version6&lt;/a>과 상동&lt;/li>
&lt;li>&lt;strong>feature&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>repository&lt;/strong>: widget에서 사용 할 데이터 핸들링을 담당한다. react query가 api type으로 데이터를 제공하는 경우, type 형태로 매핑하는 역할도 담당한다.&lt;/li>
&lt;li>&lt;strong>query&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>react query&lt;/strong>: API를 통해 받은 데이터의 상태를 관리한다.&lt;/li>
&lt;li>&lt;strong>api&lt;/strong>: react query에서 사용할 API의 호출 역할을 갖는다.&lt;/li>
&lt;li>&lt;strong>api type&lt;/strong>: API를 통해 받은 데이터를 매핑하기 위한 타입을 정의한다. API에서 주는 데이터와 widget에서 사용하는 type이 다를경우 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="version8">version8&lt;/h2>
&lt;p>서버에서 화면전용 API를 제공해주지 않고, 각 feature가 여러개의 API를 조합하여 사용해야하는 경우를 대비한 아키텍처이다.&lt;/p>
&lt;p>범용 아키텍처를 지향하므로 react query 부분도 optional하게 변경하였다.&lt;/p>
&lt;p>&lt;img src="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version8.png"
width="2042"
height="1888"
srcset="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version8_hu2a41ba1520f1feb5bea44cccd4238af3_258974_480x0_resize_box_3.png 480w, https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version8_hu2a41ba1520f1feb5bea44cccd4238af3_258974_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="version8"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p>
&lt;ul>
&lt;li>이하를 제외하고는 &lt;a class="link" href="#version7" >version7&lt;/a>과 상동&lt;/li>
&lt;li>&lt;strong>feature&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>repository&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>repository&lt;/strong>: widget에서 사용 할 데이터 핸들링을 담당한다.&lt;/li>
&lt;li>&lt;strong>react query&lt;/strong>: n개의 API를 통해 받은 데이터의 상태를 통합하여 관리한다. api type을 type 형태로 매핑하는 역할도 담당한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>query&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>api&lt;/strong>: 서버가 제공하는 API의 호출 역할을 갖는다.&lt;/li>
&lt;li>&lt;strong>api type&lt;/strong>: API를 통해 받은 데이터를 매핑하기 위한 타입을 정의한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="version9">version9&lt;/h2>
&lt;p>feature와 관계없이 공통으로 사용되어야 하는 요소들을 위치시키기위해 common widget을 추가하였다.&lt;/p>
&lt;p>(ex. 시스템에 등록되어 있는 전체 회원이 표시되는 dropdown component)&lt;/p>
&lt;p>또한 선택적으로 사용되는 부분의 경우 점선을 이용하여 선택 이용 부분임을 나타내었다.&lt;/p>
&lt;p>&lt;img src="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version9.png"
width="2282"
height="2058"
srcset="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version9_hu2b645a08818623256efad3b0e2770e6d_306820_480x0_resize_box_3.png 480w, https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version9_hu2b645a08818623256efad3b0e2770e6d_306820_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="version9"
class="gallery-image"
data-flex-grow="110"
data-flex-basis="266px"
>&lt;/p>
&lt;ul>
&lt;li>이하를 제외하고는 &lt;a class="link" href="#version8" >version8&lt;/a>과 상동&lt;/li>
&lt;li>&lt;strong>common widget&lt;/strong>: 2개 이상의 feature내 widget에서 공통으로 사용 될 widget 모음
&lt;ul>
&lt;li>&lt;strong>widget&lt;/strong>: 공통 widget에 대한 component, repository를 조합하는 역할을 한다. 외부에서 common widget을 호출 할 때의 진입점&lt;/li>
&lt;li>&lt;strong>repository&lt;/strong>: widget에서 필요로 하는 데이터를 공급하는 역할을 한다.&lt;/li>
&lt;li>&lt;strong>component&lt;/strong>: widget의 markup, style을 담당한다.&lt;/li>
&lt;li>&lt;strong>type&lt;/strong>: widget에서 사용하는 데이터의 타입을 정의한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="version10">version10&lt;/h2>
&lt;p>단순 CRUD가 아닌 비즈니스 로직에 대한 책임을 갖는 요소가 없어서 Service를 도입하였다. Repository는 필요 시 사용하고, Service를 통해서만 접근하도록 하였다.&lt;/p>
&lt;p>또한 영속화 데이터에 대한 관리를 Repository에게 위임함으로서, React Query를 생략하였다.&lt;/p>
&lt;p>&lt;img src="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version10.png"
width="2282"
height="2058"
srcset="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version10_hu625948a58e22e1dae2edadef433a5e3e_301745_480x0_resize_box_3.png 480w, https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version10_hu625948a58e22e1dae2edadef433a5e3e_301745_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="version10"
class="gallery-image"
data-flex-grow="110"
data-flex-basis="266px"
>&lt;/p>
&lt;ul>
&lt;li>이하를 제외하고는 &lt;a class="link" href="#version9" >version9&lt;/a>과 상동&lt;/li>
&lt;li>&lt;strong>service&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>service&lt;/strong>: 비즈니스 로직을 수행 할 책임을 갖는다. 실제 비즈니스 로직은 API를 통해 서버에 위임 할수도 있고, 클라이언트에서 수행 할 수도 있다.&lt;/li>
&lt;li>&lt;strong>repository&lt;/strong>: widget에서 사용 할 데이터 로직 및 상태관리를 수행한다. 필요에 따라 내부에서는 React Query를 사용 할 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="version11">version11&lt;/h2>
&lt;p>widget에서 공통 component를 사용 할 때, 커스텀해서 사용해야 하는 경우가 빈번하게 발생하고, 그럴 경우 커스텀하는 코드가 widget에 섞이게 되는 문제가 확인되었다.&lt;/p>
&lt;p>이를 피하기위해 공통 component를 사용하는 곳을 feature component로 이동시키고, widget은 feature component만 사용하는 방식으로 수정하였다.&lt;/p>
&lt;p>&lt;img src="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version11.png"
width="2282"
height="2032"
srcset="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version11_hua6540f92a9a3b4d4ebf07c77070e3e7f_300468_480x0_resize_box_3.png 480w, https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version11_hua6540f92a9a3b4d4ebf07c77070e3e7f_300468_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="version11"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="269px"
>&lt;/p>
&lt;h2 id="version11---simple">version11 - simple&lt;/h2>
&lt;p>version이 올라갈 수록 아키텍처가 복잡해져서, 선택적 요소를 제외한 가장 단순한 아키텍처를 다시 그려보았다.&lt;/p>
&lt;p>&lt;img src="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version11-simple.png"
width="1882"
height="1282"
srcset="https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version11-simple_hua4ea7ee334025a0857581a1c5a30ef8d_155368_480x0_resize_box_3.png 480w, https://blog.seungyeop-lee.com/post/react-standard-architecture/front-archetecture-version11-simple_hua4ea7ee334025a0857581a1c5a30ef8d_155368_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="version11-simple"
class="gallery-image"
data-flex-grow="146"
data-flex-basis="352px"
>&lt;/p>
&lt;h2 id="ref">ref.&lt;/h2>
&lt;ul>
&lt;li>&lt;a class="link" href="https://medium.com/@yujso66/%EB%B2%88%EC%97%AD-%EC%9C%84%EC%A0%AF-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-b3e95b261c18" title="[번역] 위젯 주도 개발"
target="_blank" rel="noopener"
>[번역] 위젯 주도 개발&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/alan2207/bulletproof-react" title="Bulletproof React"
target="_blank" rel="noopener"
>Bulletproof React&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>CSS Tips</title><link>https://blog.seungyeop-lee.com/post/css-tips/</link><pubDate>Fri, 23 Sep 2022 00:00:00 +0000</pubDate><guid>https://blog.seungyeop-lee.com/post/css-tips/</guid><description>&lt;img src="https://blog.seungyeop-lee.com/post/css-tips/cover.png" alt="Featured image of post CSS Tips" />&lt;h2 id="상속">상속&lt;/h2>
&lt;p>부모로부터 상속받은 속성은 브라우저의 디폴트 CSS 속성보다 우선순위가 낮다.&lt;/p>
&lt;h2 id="여백-상쇄">여백 상쇄&lt;/h2>
&lt;p>여백 상쇄(margin collapsing)로 인해 margin이 설정한 것과 다르게 보이는 경우가 있다. (&lt;a class="link" href="https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="noopener"
>참조&lt;/a>)&lt;/p>
&lt;ol>
&lt;li>둘 다 margin을 가진 인접 형제 요소&lt;/li>
&lt;li>첫째 및/또는 마지막 (혹은 유일한)의 자식 요소에 margin이 설정된 하나 또는 둘 이상의 자식 요소를 가진 부모 요소 (자식의 margin이 부모의 margin보다 클 경우 발생)&lt;/li>
&lt;/ol>
&lt;h2 id="줄바꿈-문자">줄바꿈 문자&lt;/h2>
&lt;p>줄바꿈 문자도 문자로 판단하여, 그만큼의 공간을 차지한다.&lt;/p>
&lt;h3 id="예시">예시&lt;/h3>
&lt;p>두 태그를 한 줄에 놓는 html 예제&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">html&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">head&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">style&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">*&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">box-sizing&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">border-box&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="nc">main-div&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">display&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">inline-block&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">width&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">50&lt;/span>&lt;span class="kt">px&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="nc">main-nav&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">display&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">inline-block&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c">/* main-div 50px + 줄 바꿈 기호(공백) 5px */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">width&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">calc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="kt">%&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">55&lt;/span>&lt;span class="kt">px&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">style&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">head&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">body&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">div&lt;/span> &lt;span class="na">class&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;main-div&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 내용1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">div&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">nav&lt;/span> &lt;span class="na">class&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;main-nav&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 내용2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">nav&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">body&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">html&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="2개-이상의-클래스">2개 이상의 클래스&lt;/h2>
&lt;p>2개 이상의 클래스가 1개의 태그에 설정 된 경우 클래스를 선택자로 하여 정의한 CSS 적용 룰&lt;/p>
&lt;ul>
&lt;li>태그에 선언된 클래스의 선언 순서는 영향을 미치지 않는다.&lt;/li>
&lt;li>태그에 선언된 클래스를 선택자로 한 CSS의 정의 순서만이 적용에 영향을 미친다.
&lt;ul>
&lt;li>나중에 정의된 CSS가 먼저 정의된 CSS를 덮어쓴다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="border-vs-outline">border vs. outline&lt;/h2>
&lt;p>border는 box model의 일부이며, outline은 box model에 속하지 않는다. outline은 border를 포함해서 요소를 완전히 둘러싼다. outline의 경우 해당 요소를 특별히 강조하기 위해 사용된다. (&lt;a class="link" href="https://cssdeck.com/blog/css-tips-outline-vs-border/" target="_blank" rel="noopener"
>참고&lt;/a>)&lt;/p>
&lt;h2 id="margin-auto">&lt;code>margin: auto&lt;/code>&lt;/h2>
&lt;p>&lt;code>margin: auto&lt;/code>로 할 경우, 해당 태그가 width나 height 기준으로 100%에 맞도록 자동으로 margin을 추가해준다.
일반적으로는 width를 % 단위로 줄이고, &lt;code>margin: auto&lt;/code>를 사용하여 중앙 정렬을 할 때 많이 사용된다.&lt;/p>
&lt;h2 id="동일-z-index">동일 z-index&lt;/h2>
&lt;p>&lt;code>position: fixed&lt;/code>인 2개 이상의 태그가 동일한 z-index를 가진경우에는 나중에 정의된 태그가 더 위에 위치한다.&lt;/p>
&lt;h2 id="stacking-context">stacking context&lt;/h2>
&lt;p>형제 태그에 대한 z-index 적용은 서로 독립적이어서, 자식 태그의 z-index는 부모 태그에게만 영향을 줄 수 있다. (&lt;a class="link" href="https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener"
>참고&lt;/a>)&lt;/p>
&lt;h2 id="이미지와-컨테이너-사이에-공백이-생기는-문제-대응">이미지와 컨테이너 사이에 공백이 생기는 문제 대응&lt;/h2>
&lt;p>컨테이너가 둘려진 이미지가 인라인 요소라면 컨테이너에 공백이 생기는 버그가 있다. 해결하기 위한 방법은 아래와 같다.&lt;/p>
&lt;ol>
&lt;li>이미지에 &lt;code>vertial-align: top&lt;/code>을 설정&lt;/li>
&lt;li>이미지를 &lt;code>display: block&lt;/code>으로 변경&lt;/li>
&lt;/ol></description></item></channel></rss>