[{"content":"프로그래머의 뇌란 책을 읽고, 인상 깊었던 내용을 정리한다.\n코드가 초래하는 세 가지 종류의 혼란  지식의 부족  프로그래밍 언어나 알고리즘, 업무 영역에 대한 지식 부족 LTM의 문제   정보의 부족  라이브러리, 모듈, 패키지 등의 정보 (ex. 움직임) 부족 STM의 문제   처리 능력의 부족  코드가 너무 복잡해서, 두뇌의 처리 용량이 부족 작업 기억 공간의 문제    코딩에 영향을 주는 인지 과정  LTM (Long Term Memory)  기억이 아주 오랫동안 보관되며, 별 노력 없이 인출이 가능하다. 프로그래밍에서는 추상적인 알고리즘, 프로그래밍 언어의 문법 뿐 아니라 키보드로 입력하는 동작을 기억하는 것까지 포함한다. 컴퓨터의 하드 드라이브와 비슷   STM (Short Term Memory)  들어오는 정보를 잠시 보관하기 위해 사용 크기에 제한이 있으며, 최대 12개를 넘지 않는다고 알려져 있다. 코드에서 키워드, 변수명, 자료구조 등을 기억하는 것을 포함한다. 컴퓨터의 메인 메모리와 비슷   작업 기억 공간  실제 사고 작용이 일어나는 공간 컴퓨터의 프로세서와 비슷    코드를 읽는 동안 LTM, STM, 작업 기억 공간이 상보적으로 같이 일어난다.\n 정보 -\u0026gt; 필터 -\u0026gt; STM -\u0026gt; 작업 기억 공간 -\u0026gt; LTM  코드를 신속하게 읽는 방법 사람의 STM 용량은 2~6개 사이로 추정되며, 용량을 향상 시킬 수 없다. 그로 인해 생소한 코드를 읽는 것에 어려움을 느낀다. 청크를 이용하여 STM의 용량 한계를 극복할 수 있다.\n청크 (chunk) 몇 개의 그룹으로 묶은 정보, 하나의 청크는 STM의 기억 공간 하나만 차지한다.\n LTM에 지식이 많으면 그 지식으로 인해 청킹(chunking) 하기 용이하고, 결과적으로는 코드를 읽기 수월해진다. 반대로 뛰어난 프로그래머라도 LTM에 아직 저장되지 않은 지식을 이용한 코드 읽기에는 어려움을 겪는다.  ex. 키워드, 구조, 도메인 개념 등    청킹 효율 향상 방법  코드에서 자주 사용되고, 예상 가능한 흐름  ex. 디자인 패턴, 프로그래밍 구성 요소, 도메인 지식 디자인 패턴을 교육 후, 해당 디자인 패턴으로 만들어진 코드를 수정하게 할 경우 더 짧은 시간에 수정을 완료하였다. 디자인 패턴이 적용되지 않은 코드를 수정할 경우에는 수정시간에 차이가 거의 없었다.   고수준 주석문  ex. 이 함수는 주어진 이진 트리를 중위 순회하며 프린트한다. 저수준 주석문은 오히려 청킹 작업에 부담이 된다. (ex. i++; //i를 1만큼 증가)   표식  단순 표식: 식별자 (변수명, 클래스명, 메서드명), 연산자, 구조문 등 복합 표식: 2개 이상의 단순 표식을 합친 표식 청크보단 작은 범위를 나타냄    문법을 기억하는 것이 중요한 이유 문법 검색 등으로 업무가 중단되면 효율성에 큰 문제를 야기한다.\n 보통 코딩 중단 후 다시 업무로 돌아가는데 약 15분 정도가 걸림 메서드 수정 작업 도중 중단이 되고 나서 1분 이내에 하던 일을 다시 시작하는 경우는 10% 정도밖에 되지 않음 업무가 중단되면 그동안 코드에 대한 중요한 정보를 잊어버리기 때문  플래시카드를 통한 학습  플래시카드를 사용하기 좋을 때  새로운 프로그래밍 언어나 프레임워크, 라이브러리를 배울 때 나오는 새로운 개념 학습 어떤 개념을 검색할 때 (중요하다고 판단되는 개념만)   연속으로 카드의 내용을 맞추면 개수를 줄이자  오랫동안 기억을 유지하는 비결  오랫동안 학습한 만큼 더 오래 기억한다.  많은 시간 학습해야 한다는 것을 의미하는게 아님 계속 반복하는 것이 중요    저장 강도와 인출 강도 LTM으로부터 기억을 가져오는 두가지 기제가 존재한다.\n 저장 강도: LTM에 얼마나 잘 저장하고 있는가 인출 강도: 무언가를 얼마나 쉽게 기억할 수 있는가  두 강도의 상관관계  저장 강도는 감소하지 않고 늘어나는 반면 인출 강도는 시간이 흐를수록 약해진다. 학습을 추가로 하지 않고 정보를 기억하려고 능동적으로 노력하는 것만으로도 배운 것을 많이 기억할 수 있다.  문법을 기억하지 않음의 악순환  너무 쉽게 정보를 찾고 너무 일상적으로 이뤄지다 보니 우리 두뇌는 문법을 기억할 필요가 없다고 느낀다. 따라서 프로그래밍 문법에 대한 인출 강도가 강화되지 않고 계속 약한 상태로 남아 있게 된다. 기억하지 않기 때문에 그것을 찾아보는것이다. 기억하려고 애쓰기보다는 찾아보는 것만 계속하기 때문에 이러한 프로그래밍 개념에 대한 인출강도가 발전하지 않는 것이고 이 인출 강도가 약하기 때문에 외우는 대신 찾아보는 악순환이 이어진다.\n 스키마와 정교화  스키마(schema): 사고나 생각이 서로 관련되어 조직된 방식  ex. 1, 3, 15, 127, 63, 31 =\u0026gt; 이진수로 표현했을 때 모두 1로만 이루어진 숫자   정교화(eleboration): 기억하고자 하는 내용을 기존 기억과 연관 지으면서 생각하는 것, LTM에 이미 저장된 스키마타에 맞춰서 새로운 기억이 저장되는 것  ex. java의 반복문을 알고있는 사람이 golang의 반복문을 학습하는 경우    ","date":"2022-04-17T00:00:00Z","image":"https://seungyeop-lee.github.io/blog/post/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-%EC%9A%94%EC%95%BD/cover_hu2fbe50cd98952bbb1f910a6538570bf6_215725_120x120_fill_box_smart1_3.png","permalink":"https://seungyeop-lee.github.io/blog/post/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-%EC%9A%94%EC%95%BD/","title":"프로그래머의 뇌 요약"},{"content":"목차  블로그 만들기 github pages로 배포하기 기본 설정 포스팅 작성 블로그 꾸미기 utterances로 댓글기능 추가하기  목표  블로그 진입점을 github pages의 루트가 아닌, 서브 path로 합니다.  ex. https://seungyeop-lee.github.io/test-blog/   하나의 repository에서 hugo의 소스파일과 생성된 html을 전부 관리합니다. github actions를 이용하여 push 할 경우, 자동으로 배포가 되게 합니다. utterances를 사용하여 댓글도 같은 repository에서 관리합니다.  실습전 확인 사항 주의 시간이 지남에 따라 내용이 정확하지 않을 수 있습니다. 화면이나 움직임이 다를경우 공식 문서를 참고해주세요.\n hugo github pages utterances  전제 조건  git 설치 github 계정 준비  실습 환경  macOS 환경 brew, vscode 사용  ","date":"2021-02-13T00:00:00Z","image":"https://seungyeop-lee.github.io/blog/post/hugo%EC%99%80-github-pages%EB%A1%9C-%EA%B0%84%EB%8B%A8%ED%9E%88-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/index/hugo%EC%99%80-github-pages%EB%A1%9C-%EA%B0%84%EB%8B%A8%ED%9E%88-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0_hu597feed4fa591234610a30ebad614589_25015_120x120_fill_box_smart1_3.png","permalink":"https://seungyeop-lee.github.io/blog/post/hugo%EC%99%80-github-pages%EB%A1%9C-%EA%B0%84%EB%8B%A8%ED%9E%88-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/index/","title":"hugo와 github pages로 간단히 블로그 만들기"}]